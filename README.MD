# EDO School Shipbuilding ICS Simulator

This repository contains all necessary files to deploy the ICS simulator on Heroku. All necessary dependencies are contained in both the environment.yml and requirements.txt files. The author created the simulator in an Anaconda environment using Python 3.7. 

```ics_main.py``` is the main script containing the simulator. The script uses the Streamlit library for web app integration. No HTML or CSS is required to deploy. There are very few parameters one would ever need to adjust within ```ics_main.py```, but each will be lited below.

## User passwords
These can be found in the ```main()``` function within ics_main.py, stored as a list in the variable _passwords._ The passwords are used to assign the number of tests to be performed. This is done in the ```perform_calcs()``` function, as a dictionary stored in the _test_dict_ variable. The names of the passwords and the number of tests can easily be changed. Remember to change the password names in both locations.

The administrator password bypasses the built-in wait time that the other passwords have.

## CDD parameters
These are found in ```perform_calcs()``` and are the threshold values taken from the CDD.

## Normal distribution parameters
The outputs of the simulation are based on creating a normal distribution for each KPP to determine how far from the CDD threshold value the KPP is allowed to deviate. These are the p1, p2, and p3 variables in the ```perform_calcs()``` function. They are generated from Numpy's random.normal function, which take the mean and standard deviation as arguments. A user selection of a "low" parameter, such as an engine size of "small" of a fuel capacity of "minimum" invokes p1 for that KPP, which has a mean of less than 1. Selection of "moderate" and "high" parameters result in p2 and p3 respectively, with means of 1.0 and greater than 1.0. The standard deviation for each random variable p1, p2, and p3 are generated by randomly sampling a uniform distribution. This sample is then multiplied by the p1, p2, and p3 means respectively, in order to create a standard deviation that is proportional to the mean. Numpy's random.uniform function takes a minimum and maximum value for the distribution as inputs. 

A dictionary, _param_dict_, is used to store the random variables, and then the variable is matched to the user's choice. The KPP threshold value is multiplied by the random variable to create values that vary from test to test, simulating a real-life scenario where different prototypes and tests have different results. The random variables are re-created for each parameter for each test, so that no two results are the same. The speed parameter has an additional variable, _form_mult_ which accounts for speed gains that can be achieved by using different hullforms. 

## Time per test
This can be adjusted by changing _test_len_, which is set in the ```progress_bar()``` function. The first part of the _if_ statement is for the administrator password, and that should be left ar 1 second for the purpose of testing code functionality. The second part sets the time for all other passwords. The _test_len_ parameter is in seconds. 

Note that as the user orders more tests, a learning curve is achieved, and every 5 tests the total time to conduct the next 5 batches of tests is reduced by _test_len_. That is, let's say the _test_len_ parameter is currently set to 120 seconds (2 minutes). If the user orders 15 tests, the test time parameter computes the total time to run all 15 tests as 1440 seconds (24 minutes). Note that this is less than 30 minutes. Each batch of 5 tests reduces the time by 2 minutes. Therefore, 3 batches of 5 tests reduces the total time by 3 * 2 = 6 minutes.

## Control flow of ics_main.py

When running, the flow of information through the script is as follows:

Heroku runs the script ics_main.py. The statement at the very bottom of the script 

```if __name__ == '__main__': main() ```

causes the function ```main()``` to be called. ```main()``` displays the title and asks the user for a password. The user input is converted to lowercase and compared to the list of passwords. If the password is invalid, the user is prompted to try again. If the password is in the list of passwords, ```get_selections()``` is called.

```get_selections()``` creates the drop-down menus for the user to select the ship configuration. All of the conditional if statements prevent the other menus from appearing until the user makes the prior selection. Once the final selection is made, all selections are converted to lowercase, and _selections_complete_ is converted to ```True```. This renders the 'Begin Testing' button. Once the user clicks the button, ```perform_calcs()``` is called.

```perform_calcs()``` initializes all variables, creates the dictionary matching the password to the number of tests, and loops through all tests, computing a new KPP values each time. It also caps the Ao value at 1.0. All computations are completed when ```perform_calcs()``` is called. However, to create the imposed wait time per test, ```progress_bar()``` is called after computations are complete. The last 3 lines of ```perform_calcs()``` call ```progress_bar()``` and then calls ```show_results()``` when ```progress_bar()``` finishes. This is done by having ```progress_bar()``` return the string 'complete'.

```progress_bar()``` renders the progress bar on screen, advancing it based on how much time has elapsed. The loop will be executed once for each second of wait time. The call to ```time.sleep(1)``` forces the loop to wait for 1 second prior to executing the next iteration. This is what actually creates the wait time. Otherwise, the entire loop would be executed at machine clock speed, and the whole thing would be finished imperceptably fast. The administrator password sets _test_len_ = 1, which allows the program to be executed in mere seconds, but is slow enough to allow the administrator to see that everything is functioning as expected.

Once ```progress_bar()``` is complete, it returns the string 'complete' back to ```perform_calcs()```, which is stored in the variable _prog_. Once it sees that ```prog == 'complete'```, ```show_results()``` is called. The purpose of ```show_results()``` is to display the average of the test results on screen, along with rendering graphs of all individual tests and their means. When ```show_results()``` has completed executing, there are no more function calls, and the program has completed running.